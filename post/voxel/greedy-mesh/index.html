<!DOCTYPE html>
<html lang="en-us">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Greedy Meshing for Vertex Colored Voxels In Unity</title>
  
  
  

  
  
  <link rel="stylesheet" href="https://eddieabbondanz.io/sass/index.min.6431904c316ae0b980d65bd42c6d77fae91ffa39e59532f7eaa3d08199571caf.css" integrity="sha256-ZDGQTDFq4LmA1lvULG13&#43;ukf&#43;jnllTL36qPQgZlXHK8=" media="screen">

</head>

<body>
  <nav class="navbar fr jcsb aic mt2-phone">
  <a class="title h100 fr aic tdn fwb" href="https://eddieabbondanz.io">
    <img class="avatar mr2" src="https://eddieabbondanz.io/img/avatar.jpg" />
    Eddie Abbondanzio
  </a>

  <div class="menu h100 aic fr-tablet dn-phone">
    
    
    <div class="item dropdown">
      <a class="trigger" href="https://eddieabbondanz.io/post">Blog
        <span class="icon"><i class="fas fa-chevron-down"></i></span>
      </a>

      <div class="content">
        <a href="https://eddieabbondanz.io/post/"> All </a>

        
        <a href="https://eddieabbondanz.io/series/development"> Development </a>
        
        <a href="https://eddieabbondanz.io/series/xj-build"> 00 XJ Build </a>
        
        <a href="https://eddieabbondanz.io/series/88-integra-build"> 88 Integra Build </a>
        
        <a href="https://eddieabbondanz.io/series/93-eg-hatch-build"> 93 EG Hatch Build </a>
        
      </div>
    </div>
    
    
    
    <a class="item single" href="https://eddieabbondanz.io/app">Apps</a>
    
    
    
    <a class="item single" href="https://eddieabbondanz.io/about">About</a>
    
    
    <div class="item social h100 fr aic px3">
      
      <a href="http://github.com/EddieAbbondanzio" target="_blank" title="GitHub">
        <span class="icon">
          <i class="fab fa-github fa-lg"></i>
        </span>
      </a>
      
      <a href="https://www.linkedin.com/in/ed-abbondanzio-5a7378208/" target="_blank" title="Linkedin">
        <span class="icon">
          <i class="fab fa-linkedin fa-lg"></i>
        </span>
      </a>
      
    </div>
  </div>

  <a id="hamburger" class="hamburger " href="#" title="Linkedin">
    <span class="icon">
      <i class="fa fa-bars fa-lg"></i>
    </span>
  </a>

</nav>
  <div id="hamburger-menu" class="hamburger-menu">
     

    <div>
      <a> Blog </a>

      <div class="ml2">
        <a href="https://eddieabbondanz.io/post/"> All </a>

        
        <a href="https://eddieabbondanz.io/series/development"> Development </a>
        
        <a href="https://eddieabbondanz.io/series/xj-build"> 00 XJ Build </a>
        
        <a href="https://eddieabbondanz.io/series/88-integra-build"> 88 Integra Build </a>
        
        <a href="https://eddieabbondanz.io/series/93-eg-hatch-build"> 93 EG Hatch Build </a>
        
      </div>
    </div>
     
    <a href="https://eddieabbondanz.io/app">Apps</a>
     
    <a href="https://eddieabbondanz.io/about">About</a>
    

    <div class="fr jcse">
      
      <a href="http://github.com/EddieAbbondanzio" target="_blank">
        <span class="icon is-medium">
          <i class="fab fa-github fa-lg"></i>
        </span>
      </a>
      
      <a href="https://www.linkedin.com/in/ed-abbondanzio-5a7378208/" target="_blank">
        <span class="icon is-medium">
          <i class="fab fa-linkedin fa-lg"></i>
        </span>
      </a>
      
    </div>
  </div>

  <main>
    
    <h1 class="title">Greedy Meshing for Vertex Colored Voxels In Unity</h1>
    
    
<article>
  <div class="meta pb3-phone">
    

    
    <div class="date" title="Posted on Mar 25, 2018">
      <i class="fas fa-calendar-day"></i>
      <time>Mar 25, 2018</time>
    </div>
    
  </div>

  <p><strong>TL;DR</strong> Full algorithm is at the bottom. Classes for <code>Block</code>, <code>Chunk</code>, and <code>MeshData</code> are defined below the intro.</p>
<p>This article goes over how to implement a greedy meshing algorithm for generating optimized meshes for vertex-colored voxels in Unity. The algorithm is derived from <a href="https://github.com/roboleary/GreedyMesh">Robert O&rsquo;Leary</a>, with a few alterations made.</p>
<p>The setup has been simplified, and assumes the world is only comprised of a single chunk that holds all the blocks. With a few tweaks it wouldn&rsquo;t be hard to add support for multiple chunks, but since there are several different solutions to achieve this, I&rsquo;ve left it up to the reader.</p>
<p>I prefer colored blocks over typed blocks. As such each block in my implementation holds 4 bytes of data for the color (red, green, blue, and alpha). A block is considered &ldquo;solid&rdquo; if the alpha value is maxed out.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// Block.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Block</span> {
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">byte</span> R { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">byte</span> G { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">byte</span> B { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">byte</span> A { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> Block(<span style="color:#66d9ef">byte</span> r, <span style="color:#66d9ef">byte</span> g, <span style="color:#66d9ef">byte</span> b, <span style="color:#66d9ef">byte</span> a = <span style="color:#66d9ef">byte</span>.MaxValue) {
        R = r;
        G = g;
        B = b;
        A = a;
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsSolid() =&gt; A == <span style="color:#66d9ef">byte</span>.MaxValue;
    <span style="color:#66d9ef">public</span> Color32 GetColor() =&gt; <span style="color:#66d9ef">new</span> Color32(R, G, B, A);
}
</code></pre></div><p>Blocks are held within a chunk. For performance reasons the chunk utilizes a flattened 3d array, but helper methods <code>ContainsIndex()</code> and <code>FlattenIndex()</code> are provided.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// Chunk.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> UnityEngine;

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Chunk</span> {
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">readonly</span> Vector3Int Dimensions = <span style="color:#66d9ef">new</span> Vector3Int(<span style="color:#ae81ff">32</span>, <span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">32</span>);

    <span style="color:#66d9ef">public</span> Vector3Int Position { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">private</span> Block[] blocks { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> Chunk(Vector3Int position) {
        Position = position;
        blocks = <span style="color:#66d9ef">new</span> Block[Dimensions.x * Dimensions.y * Dimensions.z];
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> SetBlock(Vector3Int index, Block block) {
        <span style="color:#66d9ef">if</span> (!ContainsIndex(index)) {
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IndexOutOfRangeException(<span style="color:#e6db74">$&#34;Chunk does not contain index: {index}&#34;</span>);
        }

        blocks[FlattenIndex(index)] = block;
    }

    <span style="color:#66d9ef">public</span> Block GetBlock(Vector3Int index) {
        <span style="color:#66d9ef">if</span> (!ContainsIndex(index)) {
            <span style="color:#66d9ef">return</span> Block.Air();
        }

        <span style="color:#66d9ef">return</span> blocks[FlattenIndex(index)];
    }

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">bool</span> ContainsIndex(Vector3Int index) =&gt;
        index.x &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; index.x &lt; Dimensions.x &amp;&amp;
        index.y &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; index.y &lt; Dimensions.y &amp;&amp;
        index.z &gt;= <span style="color:#ae81ff">0</span> &amp;&amp; index.z &lt; Dimensions.z;

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> FlattenIndex(Vector3Int index) =&gt;
        (index.z * Dimensions.x * Dimensions.y) +
        (index.y * Dimensions.x) +
        index.x;
}
</code></pre></div><p>A <code>MeshData</code> class has been created to ease passing vertices, triangles, and colors around.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// MeshData.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> UnityEngine;

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MeshData</span> {
    <span style="color:#66d9ef">public</span> Vector3[] Vertices { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span>[] Triangles { <span style="color:#66d9ef">get</span>; }
    <span style="color:#66d9ef">public</span> Color32[] Colors { <span style="color:#66d9ef">get</span>; }

    <span style="color:#66d9ef">public</span> MeshData(Vector3[] vertices, <span style="color:#66d9ef">int</span>[] triangles, Color32[] colors) {
        Vertices = vertices;
        Triangles = triangles;
        Colors = colors;
    }
}
</code></pre></div><p>And lastly, a helper class for building meshes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// MeshBuilder.cs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> System;
<span style="color:#66d9ef">using</span> System.Collections.Generic;
<span style="color:#66d9ef">using</span> UnityEngine;

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MeshBuilder</span> {
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> List&lt;Vector3&gt; vertices;
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> List&lt;<span style="color:#66d9ef">int</span>&gt; triangles;
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">readonly</span> List&lt;Color32&gt; colors;

    <span style="color:#66d9ef">public</span> MeshBuilder() {
        vertices = <span style="color:#66d9ef">new</span> List&lt;Vector3&gt;();
        triangles = <span style="color:#66d9ef">new</span> List&lt;<span style="color:#66d9ef">int</span>&gt;();
        colors = <span style="color:#66d9ef">new</span> List&lt;Color32&gt;();
    }

    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> AddSquareFace(Vector3[] vertices, Color32 color, <span style="color:#66d9ef">bool</span> isBackFace) {
        <span style="color:#66d9ef">if</span> (vertices.Length != <span style="color:#ae81ff">4</span>) {
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> ArgumentException(<span style="color:#e6db74">&#34;A square face requires 4 vertices&#34;</span>);
        }

        <span style="color:#75715e">// Add the 4 vertices, and color for each vertex.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i = <span style="color:#ae81ff">0</span>; i &lt; vertices.Length; i++) {
            <span style="color:#66d9ef">this</span>.vertices.Add(vertices[i]);
            colors.Add(color);
        }

        <span style="color:#66d9ef">if</span> (!isBackFace) {
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">4</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">3</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">2</span>);

            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">4</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">2</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">1</span>);
        } <span style="color:#66d9ef">else</span> {
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">2</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">3</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">4</span>);

            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">1</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">2</span>);
            triangles.Add(<span style="color:#66d9ef">this</span>.vertices.Count - <span style="color:#ae81ff">4</span>);
        }
    }

    <span style="color:#66d9ef">public</span> MeshData ToMeshData() {
        MeshData data = <span style="color:#66d9ef">new</span> MeshData(
            vertices.ToArray(),
            triangles.ToArray(),
            colors.ToArray()
        );

        vertices.Clear();
        triangles.Clear();
        colors.Clear();

        <span style="color:#66d9ef">return</span> data;
    }
}
</code></pre></div><p>Let&rsquo;s go ahead and define a <code>GenerateMesh()</code> method on our <code>Chunk</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-csharp" data-lang="csharp"><span style="color:#75715e">// Chunk.cs
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Chunk</span> {
    <span style="color:#66d9ef">public</span> MeshData GenerateMesh() {

    }
}
</code></pre></div><p>Within <code>GenerateMesh()</code> well want to add a loop that runs through all 6 faces of the blocks. We&rsquo;ll also want to know if the current face is a &ldquo;back&rdquo; face.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">// Iterate over each face of the blocks.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> face = <span style="color:#ae81ff">0</span>; face &lt; <span style="color:#ae81ff">6</span>; face++) {
        <span style="color:#66d9ef">bool</span> isBackFace = face &gt; <span style="color:#ae81ff">2</span>;
    }
</code></pre></div><p>To simplify things, we&rsquo;ll break down the problem into building slices of the mesh on 1 plane
at a time. Lets add some work variables for tracking which two axes we are working on. We will work
on the planes YZ, ZX, XY. Each plane will be visited twice, once to do the front faces, then
again to do the back faces.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#66d9ef">int</span> direction, workAxis1, workAxis2;

    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> face = <span style="color:#ae81ff">0</span>; face &lt; <span style="color:#ae81ff">6</span>; face++) {
        <span style="color:#66d9ef">bool</span> isBackFace = face &gt; <span style="color:#ae81ff">2</span>;
        direction = face % <span style="color:#ae81ff">3</span>;
        workAxis1 = (direction + <span style="color:#ae81ff">1</span>) % <span style="color:#ae81ff">3</span>;
        workAxis2 = (direction + <span style="color:#ae81ff">2</span>) % <span style="color:#ae81ff">3</span>;
    }
</code></pre></div><p>We still need a few more work variables. Go ahead and add the following above the for loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    MeshBuilder builder = <span style="color:#66d9ef">new</span> MeshBuilder();

    <span style="color:#66d9ef">bool</span>[,] merged;

    Vector3Int startPos, currPos, quadSize, m, n, offsetPos;
    Vector3[] vertices;

    Block startBlock;
</code></pre></div><p>Now add an inner for loop as seen below. This will work it&rsquo;s way through the chunk 1 layer at a time.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> face = <span style="color:#ae81ff">0</span>; face &lt; <span style="color:#ae81ff">6</span>; face++) {
        <span style="color:#66d9ef">bool</span> isBackFace = face &gt; <span style="color:#ae81ff">2</span>;
        direction = face % <span style="color:#ae81ff">3</span>;
        workAxis1 = (direction + <span style="color:#ae81ff">1</span>) % <span style="color:#ae81ff">3</span>;
        workAxis2 = (direction + <span style="color:#ae81ff">2</span>) % <span style="color:#ae81ff">3</span>;

        startPos = <span style="color:#66d9ef">new</span> Vector3Int();
        currPos = <span style="color:#66d9ef">new</span> Vector3Int();

        <span style="color:#75715e">// Iterate over the chunk layer by layer.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (startPos[direction] = <span style="color:#ae81ff">0</span>; startPos[direction] &lt; Dimensions[direction]; startPos[direction]++) {

        }
    }
</code></pre></div><p>We&rsquo;ll want to prep our bool array now. Since we want to be able to handle non cubic chunks we can&rsquo;t initialize it until we know which axis we are slicing. The next step is to begin building the mesh slices.</p>
<p>Start by getting the block at the current position and check to ensure that it
hasn&rsquo;t already been merged, is not an air block, and can be seen by the player. A block is considered visible to the player if the adjacent block to it is air. This will be checked via <code>IsBlockFaceVisible()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> IsBlockFaceVisible(Vector3Int blockPosition, <span style="color:#66d9ef">int</span> axis, <span style="color:#66d9ef">bool</span> backFace) {
        blockPosition[axis] += backFace ? -<span style="color:#ae81ff">1</span> : <span style="color:#ae81ff">1</span>;
        <span style="color:#66d9ef">return</span> !GetBlock(blockPosition).IsSolid();
    }
</code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">// Iterate over the chunk layer by layer.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (startPos[direction] = <span style="color:#ae81ff">0</span>; startPos[direction] &lt; Dimensions[direction]; startPos[direction]++) {
        merged = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[Dimensions[workAxis1], Dimensions[workAxis2]];

        <span style="color:#75715e">// Build the slices of the mesh.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (startPos[workAxis1] = <span style="color:#ae81ff">0</span>; startPos[workAxis1] &lt; Dimensions[workAxis1]; startPos[workAxis1]++) {
            <span style="color:#66d9ef">for</span> (startPos[workAxis2] = <span style="color:#ae81ff">0</span>; startPos[workAxis2] &lt; Dimensions[workAxis2]; startPos[workAxis2]++) {
                startBlock = GetBlock(startPos);

                <span style="color:#75715e">// If this block has already been merged, is air, or not visible skip it.
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">if</span> (merged[startPos[workAxis1], startPos[workAxis2]] || !startBlock.IsSolid() || !IsBlockFaceVisible(startPos, direction, isBackFace)) {
                    <span style="color:#66d9ef">continue</span>;
                }
            }
        }
    }
</code></pre></div><p>Reset the quad size variable (q) back to zero. This tracks how big the current face
we are creating will be.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">//Reset the work var
</span><span style="color:#75715e"></span>    quadSize = <span style="color:#66d9ef">new</span> Vector3Int();
</code></pre></div><p>Now we want to figure out how wide this face of the mesh will be. This for loop continuously
compares the next neighbor to see if it is a match to the current one.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">// Figure out the width, then save it
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (currPos = startPos, currPos[workAxis2]++; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }
    quadSize[workAxis2] = currPos[workAxis2] - startPos[workAxis2];
</code></pre></div><p>For completeness here is <code>CompareStep()</code></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">bool</span> CompareStep(Vector3Int a, Vector3Int b, <span style="color:#66d9ef">int</span> direction, <span style="color:#66d9ef">bool</span> backFace) {
    Block blockA = GetBlock(a);
    Block blockB = GetBlock(b);

    <span style="color:#66d9ef">return</span> blockA == blockB &amp;&amp; blockB.IsSolid() &amp;&amp; IsBlockFaceVisible(b, direction, backFace);
}
</code></pre></div><p>Now we want to repeat the same process for the height of the face.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">// Figure out the height, then save it
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (currPos = startPos, currPos[workAxis1]++; currPos[workAxis1] &lt; Dimensions[workAxis1] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis1]++) {
        <span style="color:#66d9ef">for</span> (currPos[workAxis2] = startPos[workAxis2]; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }

        <span style="color:#75715e">// If we didn&#39;t reach the end then its not a good add.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (currPos[workAxis2] - startPos[workAxis2] &lt; quadSize[workAxis2]) {
            <span style="color:#66d9ef">break</span>;
        } <span style="color:#66d9ef">else</span> {
            currPos[workAxis2] = startPos[workAxis2];
        }
    }
    quadSize[workAxis1] = currPos[workAxis1] - startPos[workAxis1];
</code></pre></div><p>Once we have figured out the height and width of the face, we can go ahead and add it to our mesh.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">// Now we add the quad to the mesh
</span><span style="color:#75715e"></span>    m = <span style="color:#66d9ef">new</span> Vector3Int();
    m[workAxis1] = quadSize[workAxis1];

    n = <span style="color:#66d9ef">new</span> Vector3Int();
    n[workAxis2] = quadSize[workAxis2];

    <span style="color:#75715e">// We need to add a slight offset when working with front faces.
</span><span style="color:#75715e"></span>    offsetPos = startPos;
    offsetPos[direction] += isBackFace ? <span style="color:#ae81ff">0</span> : <span style="color:#ae81ff">1</span>;

    <span style="color:#75715e">//Draw the face to the mesh
</span><span style="color:#75715e"></span>    vertices = <span style="color:#66d9ef">new</span> Vector3[] {
        offsetPos,
        offsetPos + m,
        offsetPos + m + n,
        offsetPos + n
    };

    builder.AddSquareFace(vertices, startBlock.GetColor(), isBackFace);
</code></pre></div><p>And lastly we need to mark all the blocks we visited as merged.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#75715e">// Mark it merged
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> f = <span style="color:#ae81ff">0</span>; f &lt; quadSize[workAxis1]; f++) {
        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> g = <span style="color:#ae81ff">0</span>; g &lt; quadSize[workAxis2]; g++) {
            merged[startPos[workAxis1] + f, startPos[workAxis2] + g] = <span style="color:#66d9ef">true</span>;
        }
    }
</code></pre></div><p>Here&rsquo;s the full algorithm for those who like to see the big picture.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    <span style="color:#66d9ef">public</span> MeshData GenerateMesh() {
        MeshBuilder builder = <span style="color:#66d9ef">new</span> MeshBuilder();
        <span style="color:#66d9ef">bool</span>[,] merged;

        Vector3Int startPos, currPos, quadSize, m, n, offsetPos;
        Vector3[] vertices;

        Block startBlock;
        <span style="color:#66d9ef">int</span> direction, workAxis1, workAxis2;

        <span style="color:#75715e">// Iterate over each face of the blocks.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> face = <span style="color:#ae81ff">0</span>; face &lt; <span style="color:#ae81ff">6</span>; face++) {
            <span style="color:#66d9ef">bool</span> isBackFace = face &gt; <span style="color:#ae81ff">2</span>;
            direction = face % <span style="color:#ae81ff">3</span>;
            workAxis1 = (direction + <span style="color:#ae81ff">1</span>) % <span style="color:#ae81ff">3</span>;
            workAxis2 = (direction + <span style="color:#ae81ff">2</span>) % <span style="color:#ae81ff">3</span>;

            startPos = <span style="color:#66d9ef">new</span> Vector3Int();
            currPos = <span style="color:#66d9ef">new</span> Vector3Int();

            <span style="color:#75715e">// Iterate over the chunk layer by layer.
</span><span style="color:#75715e"></span>            <span style="color:#66d9ef">for</span> (startPos[direction] = <span style="color:#ae81ff">0</span>; startPos[direction] &lt; Dimensions[direction]; startPos[direction]++) {
                merged = <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">bool</span>[Dimensions[workAxis1], Dimensions[workAxis2]];

                <span style="color:#75715e">// Build the slices of the mesh.
</span><span style="color:#75715e"></span>                <span style="color:#66d9ef">for</span> (startPos[workAxis1] = <span style="color:#ae81ff">0</span>; startPos[workAxis1] &lt; Dimensions[workAxis1]; startPos[workAxis1]++) {
                    <span style="color:#66d9ef">for</span> (startPos[workAxis2] = <span style="color:#ae81ff">0</span>; startPos[workAxis2] &lt; Dimensions[workAxis2]; startPos[workAxis2]++) {
                        startBlock = GetBlock(startPos);

                        <span style="color:#75715e">// If this block has already been merged, is air, or not visible skip it.
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">if</span> (merged[startPos[workAxis1], startPos[workAxis2]] || !startBlock.IsSolid() || !IsBlockFaceVisible(startPos, direction, isBackFace)) {
                            <span style="color:#66d9ef">continue</span>;
                        }

                        <span style="color:#75715e">// Reset the work var
</span><span style="color:#75715e"></span>                        quadSize = <span style="color:#66d9ef">new</span> Vector3Int();

                        <span style="color:#75715e">// Figure out the width, then save it
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> (currPos = startPos, currPos[workAxis2]++; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }
                        quadSize[workAxis2] = currPos[workAxis2] - startPos[workAxis2];

                        <span style="color:#75715e">// Figure out the height, then save it
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> (currPos = startPos, currPos[workAxis1]++; currPos[workAxis1] &lt; Dimensions[workAxis1] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis1]++) {
                            <span style="color:#66d9ef">for</span> (currPos[workAxis2] = startPos[workAxis2]; currPos[workAxis2] &lt; Dimensions[workAxis2] &amp;&amp; CompareStep(startPos, currPos, direction, isBackFace) &amp;&amp; !merged[currPos[workAxis1], currPos[workAxis2]]; currPos[workAxis2]++) { }

                            <span style="color:#75715e">// If we didn&#39;t reach the end then its not a good add.
</span><span style="color:#75715e"></span>                            <span style="color:#66d9ef">if</span> (currPos[workAxis2] - startPos[workAxis2] &lt; quadSize[workAxis2]) {
                                <span style="color:#66d9ef">break</span>;
                            } <span style="color:#66d9ef">else</span> {
                                currPos[workAxis2] = startPos[workAxis2];
                            }
                        }
                        quadSize[workAxis1] = currPos[workAxis1] - startPos[workAxis1];

                        <span style="color:#75715e">// Now we add the quad to the mesh
</span><span style="color:#75715e"></span>                        m = <span style="color:#66d9ef">new</span> Vector3Int();
                        m[workAxis1] = quadSize[workAxis1];

                        n = <span style="color:#66d9ef">new</span> Vector3Int();
                        n[workAxis2] = quadSize[workAxis2];

                        <span style="color:#75715e">// We need to add a slight offset when working with front faces.
</span><span style="color:#75715e"></span>                        offsetPos = startPos;
                        offsetPos[direction] += isBackFace ? <span style="color:#ae81ff">0</span> : <span style="color:#ae81ff">1</span>;

                        <span style="color:#75715e">//Draw the face to the mesh
</span><span style="color:#75715e"></span>                        vertices = <span style="color:#66d9ef">new</span> Vector3[] {
                            offsetPos,
                            offsetPos + m,
                            offsetPos + m + n,
                            offsetPos + n
                        };

                        builder.AddSquareFace(vertices, startBlock.GetColor(), isBackFace);

                        <span style="color:#75715e">// Mark it merged
</span><span style="color:#75715e"></span>                        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> f = <span style="color:#ae81ff">0</span>; f &lt; quadSize[workAxis1]; f++) {
                            <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> g = <span style="color:#ae81ff">0</span>; g &lt; quadSize[workAxis2]; g++) {
                                merged[startPos[workAxis1] + f, startPos[workAxis2] + g] = <span style="color:#66d9ef">true</span>;
                            }
                        }
                    }
                }
            }
        }

        <span style="color:#66d9ef">return</span> builder.ToMeshData();
    }
</code></pre></div><p>And last but not least, if we want to render our mesh we generated we&rsquo;ll need to pass the data to a MeshFilter. For extra bonus points we could implement an extension method to make it even cleaner.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#"><span style="color:#66d9ef">using</span> UnityEngine;

<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MeshFilterExts</span> {
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> ApplyMeshData(<span style="color:#66d9ef">this</span> MeshFilter meshFilter, MeshData meshData) {
        meshFilter.mesh.Clear();
        meshFilter.mesh.vertices = meshData.Vertices;
        meshFilter.mesh.triangles = meshData.Triangles;

        <span style="color:#75715e">//Color mesh and calculate normals
</span><span style="color:#75715e"></span>        meshFilter.mesh.colors32 = meshData.Colors;
        meshFilter.mesh.RecalculateNormals();
    }
}
</code></pre></div><p>Then to render our mesh we would use it like so.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c#" data-lang="c#">    MeshData mesh = chunk.GenerateMesh();

    MeshFilter meshFilter = GetComponent&lt;MeshFilter&gt;();
    meshFilter.ApplyMeshData(mesh);
</code></pre></div>
</article>

  </main>

  <footer>
  <p>&copy; 2013 - 2023 Eddie Abbondanzio</p>
</footer>
  <script src="https://eddieabbondanz.io/js/lol.js"></script>
</body>


</html>